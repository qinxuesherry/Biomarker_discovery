}
return(accuracy_results)
}
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
accuracy_matrix
# Convert matrix to data frame for plotting
accuracy_df <- melt(accuracy_matrix)
colnames(accuracy_df) <- c("i", "j", "accuracy")
# Plot with ggplot2
ggplot(accuracy_df, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Find the highest accuracy score and corresponding (i, j) values
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
i_value <- max_indices[1]
j_value <- max_indices[2]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
apply_logic_indicators_with_accuracy <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 30, by = 0.5)
j_values <- seq(0, 30, by = 0.5)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 & data$tpsa_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
# Usage example:
# accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
accuracy_matrix
# Convert matrix to data frame for plotting
accuracy_df <- melt(accuracy_matrix)
colnames(accuracy_df) <- c("i", "j", "accuracy")
# Plot with ggplot2
ggplot(accuracy_df, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Find the highest accuracy score and corresponding (i, j) values
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
i_value <- max_indices[1]
j_value <- max_indices[2]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
apply_logic_indicators_with_accuracy <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 15, by = 0.1)
j_values <- seq(0, 15, by = 0.1)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 & data$tpsa_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
# Usage example:
# accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
accuracy_matrix
# Convert matrix to data frame for plotting
accuracy_df <- melt(accuracy_matrix)
colnames(accuracy_df) <- c("i", "j", "accuracy")
# Plot with ggplot2
ggplot(accuracy_df, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Find the highest accuracy score and corresponding (i, j) values
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
i_value <- max_indices[1]
j_value <- max_indices[2]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
apply_logic_indicators_with_accuracy <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 5, by = 0.01)
j_values <- seq(0, 10, by = 0.01)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 & data$tpsa_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
# Usage example:
# accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
accuracy_matrix
# Convert matrix to data frame for plotting
accuracy_df <- melt(accuracy_matrix)
colnames(accuracy_df) <- c("i", "j", "accuracy")
# Plot with ggplot2
ggplot(accuracy_df, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Find the highest accuracy score and corresponding (i, j) values
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
i_value <- max_indices[1]
j_value <- max_indices[2]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
apply_logic_indicators_with_accuracy_or <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 5, by = 0.01)
j_values <- seq(0, 10, by = 0.01)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 | data$tpsa_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
accuracy_matrix_or <- apply_logic_indicators_with_accuracy_or(data)
# Convert matrix to data frame for plotting
accuracy_df_or <- melt(accuracy_matrix_or)
colnames(accuracy_df_or) <- c("i", "j", "accuracy")
# Plot with ggplot2
ggplot(accuracy_df_or, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
max_accuracy_or <- max(accuracy_matrix_or)
max_indices_or <- which(accuracy_matrix_or == max_accuracy_or, arr.ind = TRUE)
i_value_or <- max_indices_or[1]
j_value_or <- max_indices_or[2]
# Print the result
cat("Highest accuracy score:", max_accuracy_or, "at (i, j) =", "(", i_value_or, ",", j_value_or, ")\n")
max_indices_or
max_indices
max_indices[3]
max_indices[34]
i_values <- seq(0, 30, by = 0.5)
j_values <- seq(0, 30, by = 0.5)
# Find the highest accuracy score and corresponding indices
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
# Use the indices to get the actual i and j values
i_value <- i_values[max_indices[1]]
j_value <- j_values[max_indices[2]]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
accuracy_matrix
apply_logic_indicators_with_accuracy <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 5, by = 0.01)
j_values <- seq(0, 10, by = 0.01)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 & data$tpsa_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
# Usage example:
# accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
i_values <- seq(0, 5, by = 0.01)
j_values <- seq(0, 10, by = 0.01)
# Find the highest accuracy score and corresponding indices
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
# Use the indices to get the actual i and j values
i_value <- i_values[max_indices[1]]
j_value <- j_values[max_indices[2]]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
write.csv(accuracy_results, "accuracy_results.csv", row.names = TRUE)
write.csv(accuracy_matrix, "accuracy_results.csv", row.names = TRUE)
max_indices
# Find the maximum accuracy value and its location
max_accuracy <- max(accuracy_results)
# Find the maximum accuracy value and its location
max_accuracy <- max(accuracy_matrix)
max_indices <- which(accuracy_matrix == max_accuracy, arr.ind = TRUE)
# Get the row and column names for the max value
i_value <- rownames(accuracy_matrix)[max_indices[1]]
j_value <- colnames(accuracy_matrix)[max_indices[2]]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
# Find the maximum accuracy value
max_accuracy <- max(accuracy_matrix, na.rm = TRUE)  # Ensure no NA values interfere
# Use arrayInd to get the first occurrence of the maximum value’s indices
max_indices <- arrayInd(which.max(accuracy_matrix), dim(accuracy_matrix))
# Get the row and column names for the max value
i_value <- rownames(accuracy_matrix)[max_indices[1]]
j_value <- colnames(accuracy_matrix)[max_indices[2]]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
max_accuracy_or <- max(accuracy_matrix_or, na.rm = TRUE)  # Ensure no NA values interfere
# Use arrayInd to get the first occurrence of the maximum value’s indices
max_indices_or <- arrayInd(which.max(accuracy_matrix_or), dim(accuracy_matrix_or))
# Get the row and column names for the max value
i_value_or <- rownames(accuracy_matrix_or)[max_indices_or[1]]
j_value_or <- colnames(accuracy_matrix_or)[max_indices_or[2]]
# Print the result
cat("Highest accuracy score:", max_accuracy_or, "at (i, j) =", "(", i_value_or, ",", j_value_or, ")\n")
# Convert matrix to data frame for plotting
accuracy_df_or <- melt(accuracy_matrix_or)
colnames(accuracy_df_or) <- c("i", "j", "accuracy")
# Plot with ggplot2
ggplot(accuracy_df_or, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
max_indices[1]
max_indices
max_indices
knitr::opts_chunk$set(echo = TRUE)
library(cutpointr)
data <- read.csv("../data/raw/psa2b.csv")
head(data)
apply_logic_indicators_with_accuracy <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 5, by = 0.01)
j_values <- seq(0, 10, by = 0.01)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 & data$tpsa_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
# Usage example:
# accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)
library(ggplot2)
library(reshape2)
# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
accuracy_df <- melt(accuracy_matrix)
colnames(accuracy_df) <- c("i", "j", "accuracy")
ggplot(accuracy_df, aes(x = j, y = i, fill = accuracy)) +
geom_tile() +
scale_fill_viridis_c() +
labs(title = "Accuracy Plot for Different (i, j) Thresholds",
x = "j values",
y = "i values",
fill = "Accuracy") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Find the maximum accuracy value
max_accuracy <- max(accuracy_matrix, na.rm = TRUE)  # Ensure no NA values interfere
# Use arrayInd to get the first occurrence of the maximum value’s indices
max_indices <- arrayInd(which.max(accuracy_matrix), dim(accuracy_matrix))
# Get the row and column names for the max value
i_value <- rownames(accuracy_matrix)[max_indices[1]]
j_value <- colnames(accuracy_matrix)[max_indices[2]]
# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")
apply_logic_indicators_with_accuracy_3 <- function(data) {
# Create a sequence for i and j from 0 to 30 with a step of 0.5
i_values <- seq(0, 5, by = 0.01)
j_values <- seq(0, 10, by = 0.01)
# Initialize matrix to store accuracy results
accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
# Set threshold values for this iteration
i_threshold <- i_values[i]
j_threshold <- j_values[j]
# Create fpsa_cut and tpsa_cut
data$two_cut <- ifelse((data$fpsa <0.2 & data$tpsa < 10 & data$tpsa > 3) , 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > 10, 1, 0)
# Combine using logic indicators
data$combined_logic <- ifelse(data$fpsa_cut == 1 | data$two_cut == 1, 1, 0)
# Calculate accuracy compared to d
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
# Store accuracy in matrix
accuracy_results[i, j] <- accuracy
}
}
# Add row and column names for easier interpretation
rownames(accuracy_results) <- i_values
colnames(accuracy_results) <- j_values
return(accuracy_results)
}
accuracy_matrix_3 <- apply_logic_indicators_with_accuracy_3(data)
apply_logic_indicators_with_accuracy_3 <- function(data) {
data$two_cut <- ifelse((data$fpsa <0.2 & data$tpsa < 10 & data$tpsa > 3) , 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > 10, 1, 0)
data$combined_logic <- ifelse(data$fpsa_cut == 1 | data$two_cut == 1, 1, 0)
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
}
}
apply_logic_indicators_with_accuracy_3 <- function(data) {
data$two_cut <- ifelse((data$fpsa <0.2 & data$tpsa < 10 & data$tpsa > 3) , 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > 10, 1, 0)
data$combined_logic <- ifelse(data$fpsa_cut == 1 | data$two_cut == 1, 1, 0)
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
}
return(accuracy)
apply_logic_indicators_with_accuracy_3 <- function(data) {
data$two_cut <- ifelse((data$fpsa <0.2 & data$tpsa < 10 & data$tpsa > 3) , 1, 0)
data$tpsa_cut <- ifelse(data$tpsa > 10, 1, 0)
data$combined_logic <- ifelse(data$fpsa_cut == 1 | data$two_cut == 1, 1, 0)
correct_predictions <- sum(data$combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
return(accuracy)
}
accuracy_matrix_3 <- apply_logic_indicators_with_accuracy_3(data)
apply_logic_indicators_with_accuracy_3 <- function(data, fpsa_threshold = 0.2, tpsa_lower = 3, tpsa_upper = 10) {
# Apply logic indicators with dynamic thresholds
two_cut <- ifelse(data$fpsa < fpsa_threshold & data$tpsa < tpsa_upper & data$tpsa > tpsa_lower, 1, 0)
tpsa_cut <- ifelse(data$tpsa > tpsa_upper, 1, 0)
# Combine logic indicators
combined_logic <- ifelse(two_cut == 1 | tpsa_cut == 1, 1, 0)
# Calculate accuracy
correct_predictions <- sum(combined_logic == data$d)
accuracy <- correct_predictions / nrow(data)
return(accuracy)
}
data <- read.csv("../data/raw/psa2b.csv")
head(data)
accuracy <- apply_logic_indicators_with_accuracy_3(data, fpsa_threshold = 0.3, tpsa_lower = 4, tpsa_upper = 12)
print(accuracy)
find_optimal_logic_thresholds <- function(data,
fpsa_range = seq(0.1, 0.5, by = 0.1),
tpsa_lower_range = seq(1, 5, by = 1),
tpsa_upper_range = seq(6, 15, by = 1)) {
# Initialize variables to store the best results
best_accuracy <- 0
best_thresholds <- list(fpsa_threshold = NA, tpsa_lower = NA, tpsa_upper = NA)
# Loop over all combinations of thresholds
for (fpsa_threshold in fpsa_range) {
for (tpsa_lower in tpsa_lower_range) {
for (tpsa_upper in tpsa_upper_range) {
# Ensure the lower bound is less than the upper bound
if (tpsa_lower < tpsa_upper) {
# Calculate accuracy for the current thresholds
accuracy <- apply_logic_indicators_with_accuracy_3(data,
fpsa_threshold = fpsa_threshold,
tpsa_lower = tpsa_lower,
tpsa_upper = tpsa_upper)
# Update best thresholds if the current accuracy is higher
if (accuracy > best_accuracy) {
best_accuracy <- accuracy
best_thresholds <- list(fpsa_threshold = fpsa_threshold,
tpsa_lower = tpsa_lower,
tpsa_upper = tpsa_upper)
}
}
}
}
}
# Return the best thresholds and corresponding accuracy
return(list(best_accuracy = best_accuracy, best_thresholds = best_thresholds))
}
results <- find_optimal_logic_thresholds(data)
print(results$best_accuracy)
print(results$best_thresholds)
