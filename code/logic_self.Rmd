---
title: "logistic_self"
author: "Xue Qin"
date: "2024-11-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(cutpointr)
```

```{r}
data <- read.csv("../data/raw/psa2b.csv")
head(data)
```
```{r}
library(dplyr)

data <- data %>%
  group_by(id) %>%
  filter(t == max(t)) %>%
  ungroup()
```


```{r}
apply_logic_indicators_with_accuracy <- function(data) {
  # Create a sequence for i and j from 0 to 30 with a step of 0.5
  i_values <- seq(0, 5, by = 0.01)
  j_values <- seq(0, 10, by = 0.01)
  
  # Initialize matrix to store accuracy results
  accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
  
  for (i in seq_along(i_values)) {
    for (j in seq_along(j_values)) {
      # Set threshold values for this iteration
      i_threshold <- i_values[i]
      j_threshold <- j_values[j]
      
      # Create fpsa_cut and tpsa_cut
      data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
      data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
      
      # Combine using logic indicators
      data$combined_logic <- ifelse(data$fpsa_cut == 1 & data$tpsa_cut == 1, 1, 0)
      
      # Calculate accuracy compared to d
      correct_predictions <- sum(data$combined_logic == data$d)
      accuracy <- correct_predictions / nrow(data)
      
      # Store accuracy in matrix
      accuracy_results[i, j] <- accuracy
    }
  }
  
  # Add row and column names for easier interpretation
  rownames(accuracy_results) <- i_values
  colnames(accuracy_results) <- j_values
  
  return(accuracy_results)
}

# Usage example:
# accuracy_matrix <- apply_logic_indicators_with_accuracy(your_data)

```



```{r}
library(ggplot2)
library(reshape2)

# Assuming accuracy_results is the 99x99 matrix generated by the function
accuracy_matrix <- apply_logic_indicators_with_accuracy(data)
```


```{r}
accuracy_df <- melt(accuracy_matrix)
colnames(accuracy_df) <- c("i", "j", "accuracy")

ggplot(accuracy_df, aes(x = j, y = i, fill = accuracy)) +
  geom_tile() +
  scale_fill_viridis_c() +
  labs(title = "Accuracy Plot for Different (tpsa, fpsa) Thresholds With And Condition",
       x = "tpsa",
       y = "fpsa",
       fill = "Accuracy") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Find the maximum accuracy value
max_accuracy <- max(accuracy_matrix, na.rm = TRUE)  # Ensure no NA values interfere

# Use arrayInd to get the first occurrence of the maximum value’s indices
max_indices <- arrayInd(which.max(accuracy_matrix), dim(accuracy_matrix))

# Get the row and column names for the max value
i_value <- rownames(accuracy_matrix)[max_indices[1]]
j_value <- colnames(accuracy_matrix)[max_indices[2]]

# Print the result
cat("Highest accuracy score:", max_accuracy, "at (i, j) =", "(", i_value, ",", j_value, ")\n")


```



## Or statement

```{r}
apply_logic_indicators_with_accuracy_or <- function(data) {
  # Create a sequence for i and j from 0 to 30 with a step of 0.5
  i_values <- seq(0, 5, by = 0.01)
  j_values <- seq(0, 10, by = 0.01)
  
  # Initialize matrix to store accuracy results
  accuracy_results <- matrix(nrow = length(i_values), ncol = length(j_values))
  
  for (i in seq_along(i_values)) {
    for (j in seq_along(j_values)) {
      # Set threshold values for this iteration
      i_threshold <- i_values[i]
      j_threshold <- j_values[j]
      
      # Create fpsa_cut and tpsa_cut
      data$fpsa_cut <- ifelse(data$fpsa > i_threshold, 1, 0)
      data$tpsa_cut <- ifelse(data$tpsa > j_threshold, 1, 0)
      
      # Combine using logic indicators
      data$combined_logic <- ifelse(data$fpsa_cut == 1 | data$tpsa_cut == 1, 1, 0)
      
      # Calculate accuracy compared to d
      correct_predictions <- sum(data$combined_logic == data$d)
      accuracy <- correct_predictions / nrow(data)
      
      # Store accuracy in matrix
      accuracy_results[i, j] <- accuracy
    }
  }
  
  # Add row and column names for easier interpretation
  rownames(accuracy_results) <- i_values
  colnames(accuracy_results) <- j_values
  
  return(accuracy_results)
}
```

```{r}
accuracy_matrix_or <- apply_logic_indicators_with_accuracy_or(data)
```

```{r}
# Convert matrix to data frame for plotting
accuracy_df_or <- melt(accuracy_matrix_or)
colnames(accuracy_df_or) <- c("i", "j", "accuracy")

# Plot with ggplot2
ggplot(accuracy_df_or, aes(x = j, y = i, fill = accuracy)) +
  geom_tile() +
  scale_fill_viridis_c() +
  labs(title = "Accuracy Plot for Different (tpsa, fpsa) Thresholds With Or Condition",
       x = "tpsa",
       y = "fpsa",
       fill = "Accuracy") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
max_accuracy_or <- max(accuracy_matrix_or, na.rm = TRUE)  # Ensure no NA values interfere

# Use arrayInd to get the first occurrence of the maximum value’s indices
max_indices_or <- arrayInd(which.max(accuracy_matrix_or), dim(accuracy_matrix_or))

# Get the row and column names for the max value
i_value_or <- rownames(accuracy_matrix_or)[max_indices_or[1]]
j_value_or <- colnames(accuracy_matrix_or)[max_indices_or[2]]

# Print the result
cat("Highest accuracy score:", max_accuracy_or, "at (i, j) =", "(", i_value_or, ",", j_value_or, ")\n")

```


## 复现

```{r}
apply_logic_indicators_with_accuracy_3 <- function(data, fpsa_threshold = 0.2, tpsa_lower = 3, tpsa_upper = 10) {
  # Apply logic indicators with dynamic thresholds
  two_cut <- ifelse(data$fpsa > fpsa_threshold & data$tpsa < tpsa_upper & data$tpsa > tpsa_lower, 1, 0)
  tpsa_cut <- ifelse(data$tpsa > tpsa_upper, 1, 0)
  
  # Combine logic indicators
  combined_logic <- ifelse(two_cut == 1 | tpsa_cut == 1, 1, 0)
  
  # Calculate accuracy
  correct_predictions <- sum(combined_logic == data$d)
  accuracy <- correct_predictions / nrow(data)
  
  return(accuracy)
}

  
```

```{r}
accuracy <- apply_logic_indicators_with_accuracy_3(data, fpsa_threshold = 0.3, tpsa_lower = 4, tpsa_upper = 12)
print(accuracy)
```



```{r}
find_optimal_logic_thresholds <- function(data, 
                                          fpsa_range = seq(0, 0.5, by = 0.01), 
                                          tpsa_lower_range = seq(1, 5, by = 0.01), 
                                          tpsa_upper_range = seq(6, 10, by = 0.01)) {
  # Initialize variables to store the best results
  best_accuracy <- 0
  best_thresholds <- list(fpsa_threshold = NA, tpsa_lower = NA, tpsa_upper = NA)
  
  # Loop over all combinations of thresholds
  for (fpsa_threshold in fpsa_range) {
    for (tpsa_lower in tpsa_lower_range) {
      for (tpsa_upper in tpsa_upper_range) {
        # Ensure the lower bound is less than the upper bound
        if (tpsa_lower < tpsa_upper) {
          # Calculate accuracy for the current thresholds
          accuracy <- apply_logic_indicators_with_accuracy_3(data, 
                                                             fpsa_threshold = fpsa_threshold, 
                                                             tpsa_lower = tpsa_lower, 
                                                             tpsa_upper = tpsa_upper)
          
          # Update best thresholds if the current accuracy is higher
          if (accuracy > best_accuracy) {
            best_accuracy <- accuracy
            best_thresholds <- list(fpsa_threshold = fpsa_threshold, 
                                    tpsa_lower = tpsa_lower, 
                                    tpsa_upper = tpsa_upper)
          }
        }
      }
    }
  }
  
  # Return the best thresholds and corresponding accuracy
  return(list(best_accuracy = best_accuracy, best_thresholds = best_thresholds))
}

```


```{r}
results <- find_optimal_logic_thresholds(data)
print(results$best_accuracy)
print(results$best_thresholds)
```
```{r}
library(DiagrammeR)

grViz("
digraph decision_tree {
  graph [layout = dot, rankdir = TB]

  node [shape = box, style = filled, fillcolor = white]

  1 [label = 'OR']
  2 [label = 'TPSA ≥ 6.27']
  3 [label = 'AND']
  4 [label = 'FPSA > 0']
  5 [label = 'AND']
  6 [label = 'TPSA ≥ 3.21']
  7 [label = 'TPSA < 6.27']

  1 -> 2
  1 -> 3
  3 -> 4
  3 -> 5
  5 -> 6
  5 -> 7
}
")

```

